#!/usr/bin/env bun

/**
 * Database Connection Test
 *
 * This script tests the database connection and Effect Config integration
 * before applying migrations.
 */

import { Effect, ConfigProvider } from "effect"
import { AutoDatabaseConfig } from "../../lib/database-naming"
import { Logger, LoggerLayer, aviationMessages } from "../../lib/logger-service"
import postgres from "postgres"

const testDatabaseConnection = Effect.gen(function* () {
  const logger = yield* Logger

  yield* logger.info(aviationMessages.starting("database connection testing"), {
    service: "database-test",
    operation: "connection-test",
  })

  // Get auto-generated database configuration
  const dbConfig = yield* AutoDatabaseConfig
  yield* logger.info(
    `Connecting to: ${dbConfig.url.replace(/:[^:@]*@/, ":****@")}`,
    {
      service: "database-test",
      operation: "connection-init",
    },
  )
  if (dbConfig.type === "auto") {
    yield* logger.info(`Auto-generated database name: ${dbConfig.name}`, {
      service: "database-test",
      metadata: { autoGenerated: true, name: dbConfig.name },
    })
  }

  // Create postgres connection
  const client = postgres(dbConfig.url, {
    max: 1,
    idle_timeout: 5,
    connect_timeout: 10,
  })

  try {
    // Test the connection
    const result = yield* Effect.tryPromise({
      try: () => client`SELECT 
        version() as postgres_version,
        current_database() as database_name,
        current_user as database_user,
        NOW() as timestamp`,
      catch: (error) => new Error(`Database connection failed: ${error}`),
    })

    const info = result[0]
    if (!info) {
      return yield* Effect.fail(new Error("No result returned from database"))
    }

    yield* logger.success("Database connection successful!", {
      service: "database-test",
      operation: "connection-success",
      metadata: {
        postgresql_version: info.postgres_version,
        database_name: info.database_name,
        database_user: info.database_user,
        timestamp: info.timestamp,
      },
    })

    // Check if any tables exist
    const tables = yield* Effect.tryPromise({
      try: () => client`
        SELECT table_name 
        FROM information_schema.tables 
        WHERE table_schema = 'public'
        ORDER BY table_name
      `,
      catch: (error) => new Error(`Failed to list tables: ${error}`),
    })

    if (tables.length > 0) {
      yield* logger.info(`Existing tables (${tables.length}):`, {
        service: "database-test",
        operation: "table-list",
        metadata: {
          tableCount: tables.length,
          tables: tables.map((t) => t.table_name),
        },
      })
    } else {
      yield* logger.info("No tables found (database is empty)", {
        service: "database-test",
        operation: "table-list",
        metadata: { tableCount: 0 },
      })
    }

    return {
      success: true,
      info,
      existingTables: tables.length,
    }
  } finally {
    // Always close the connection
    yield* Effect.tryPromise({
      try: () => client.end(),
      catch: () => new Error("Failed to close database connection"),
    })
  }
})

// Run the test with config provider and logger
const program = testDatabaseConnection.pipe(
  Effect.provide(LoggerLayer),
  Effect.withConfigProvider(ConfigProvider.fromEnv()),
  Effect.catchAll((error) =>
    Effect.gen(function* () {
      const logger = yield* Logger
      yield* logger.error(`Database connection test failed: ${error}`, {
        service: "database-test",
        operation: "test-failure",
        metadata: { error: String(error) },
      })
      return { success: false, error }
    }).pipe(Effect.provide(LoggerLayer)),
  ),
)

Effect.runPromise(program).then(
  (result: { success: boolean; error?: unknown }) => {
    if (result.success) {
      console.log("\nðŸŽ‰ Database is ready for migrations!")
      process.exit(0)
    } else {
      console.log("\nðŸ’¥ Please fix the database connection before proceeding.")
      process.exit(1)
    }
  },
)
